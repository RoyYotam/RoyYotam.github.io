<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Royxigul</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #f2f2f2;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    h1 {
      margin-bottom: 1rem;
    }
    .public-board {
      display: grid;
      grid-template-columns: repeat(3, auto);
      gap: 10px;
    }
    .local-board {
      display: grid;
      grid-template-columns: repeat(3, 30px);
      gap: 2px;
      background-color: #ddd;
      padding: 5px;
      border: 2px solid #999;
      position: relative;
      width: fit-content;
      height: fit-content;
    }
    .cell {
      width: 30px;
      height: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #fff;
      cursor: pointer;
      font-weight: bold;
    }
    .cell.disabled {
      background-color: #eee;
      cursor: not-allowed;
    }
    .highlight {
      border: 2px solid red;
    }
    .winner-cell {
      background-color: #b2fab4 !important;
    }
    #reset-btn {
      position: absolute;
      top: 20px;
      right: 60px;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
    }
    #download-replay {
      position: absolute;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
    }
    .winner-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 48px;
      font-weight: bold;
      color: #444;
      pointer-events: none;
    }
    .global-winner-board {
      box-shadow: 0 0 10px 4px #7ed957;
      position: relative;
    }
  </style>
</head>
<body>

  <script src="res/js/main_prompt.js"></script>
  <script src="res/js/prompt_utils.js"></script>

  <h1>Royxigul
    <button id="reset-btn" title="Reset Game">ðŸ”„</button>
    <button id="download-replay" title="Download Replay">ðŸ’¾</button>
  </h1>
  <div id="board" class="public-board"></div>
  <p id="status"></p>

  <label>API Key:
    <input type="text" id="apiKey" placeholder="sk-..." />
    <button id="load-btn" onclick="load_key()">Load</button>
  </label>

  <pre id="output"></pre>

  <script>
    const boardContainer = document.getElementById('board');
    const statusText = document.getElementById('status');
    const resetBtn = document.getElementById('reset-btn');
    const downloadBtn = document.getElementById('download-replay');

    let currentPlayer, nextBoardIndex, publicBoard, globalWin, moveHistory, ids_history;

    function checkWin(cells) {
      const wins = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6],
      ];
      for (const combo of wins) {
        const [a, b, c] = combo;
        if (cells[a] && cells[a] === cells[b] && cells[a] === cells[c]) {
          return { winner: cells[a], line: combo };
        }
      }
      return null;
    }

    async function createGame() {
      currentPlayer = 'X';
      nextBoardIndex = null;
      globalWin = null;
      moveHistory = [];
      ids_history = [];
      publicBoard = Array.from({ length: 9 }, (_, i) => ({
        index: i,
        cells: Array(9).fill(null),
        element: null,
        winner: null,
        winLine: [],
      }));
      await renderBoard();
      statusText.textContent = `Player ${currentPlayer}'s turn`;
    }

    async function renderBoard() {
      boardContainer.innerHTML = '';
      publicBoard.forEach((board, bIndex) => {
        const boardEl = document.createElement('div');
        boardEl.className = 'local-board';
        if (nextBoardIndex === null || nextBoardIndex === bIndex) {
          boardEl.classList.add('highlight');
        }
        if (globalWin && globalWin.line.includes(bIndex)) {
          boardEl.classList.add('global-winner-board');
        }

        board.cells.forEach((cell, cIndex) => {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          if (cell) {
            cellEl.textContent = cell;
            cellEl.classList.add('disabled');
          } else if (
            (nextBoardIndex === null || nextBoardIndex === bIndex) &&
            !board.winner
          ) {
            cellEl.onclick = async () => await handleMove(bIndex, cIndex);
          } else {
            cellEl.classList.add('disabled');
          }

          if (board.winLine.includes(cIndex)) {
            cellEl.classList.add('winner-cell');
          }

          boardEl.appendChild(cellEl);
        });

        if (board.winner) {
          const overlay = document.createElement('div');
          overlay.className = 'winner-overlay';
          overlay.textContent = board.winner;
          boardEl.appendChild(overlay);
        }

        board.element = boardEl;
        boardContainer.appendChild(boardEl);
      });
    }

    async function handleMove(bIndex, cIndex) {
      const board = publicBoard[bIndex];
      if (board.cells[cIndex] || board.winner) return;

      board.cells[cIndex] = currentPlayer;
      moveHistory.push({ player: currentPlayer, board: bIndex + 1, cell: cIndex + 1});

      const winResult = checkWin(board.cells);
      if (winResult) {
        board.winner = winResult.winner;
        board.winLine = winResult.line;
        board.element.style.backgroundColor = winResult.winner === 'X' ? '#cfc' : '#ccf';
      }

      const globalCheck = checkWin(publicBoard.map(b => b.winner));
      if (globalCheck) {
        globalWin = globalCheck;
        statusText.textContent = `Player ${globalWin.winner} wins the game!`;
        await disableAll();
        return;
      }

      nextBoardIndex = publicBoard[cIndex].winner || publicBoard[cIndex].cells.every(c => c) ? null : cIndex;
      currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
      statusText.textContent = `Player ${currentPlayer}'s turn`;
      await renderBoard();

      console.log(availableMoves(cIndex));

      if (currentPlayer === 'O') {
        const result = [
                {
                  role: "system",
                  content: [
                          {
                            type: "input_text",
                            text: window.systemPrompt
                          }
                          ]
                }
                ];


        let assistantIndex = 0;

        for (const move of moveHistory) {
          const entry = {
            role: move.player === "X" ? "user" : "assistant",
            content: [
                    {
                      type:  move.player === "X" ? "input_text" : "output_text",
                      text: `${move.board}${move.cell}`
                    }
                    ]
          };

          if (move.player === "O") {
            entry.id = ids_history[assistantIndex];
            assistantIndex++;
          }

          result.push(entry);
        }

        result.push({
            role: "user",
            content: [
                    {
                      type: "input_text",
                      text: `Available moves: ${availableMoves(cIndex)}`
                    }
                    ]
          });

        const res = await runTurn(result);

        ids_history.push(res[1]);
        const board = parseInt(res[0][0])
        const cell = parseInt(res[0][1])

        await handleMove(board - 1, cell - 1);
      }
    }

    function availableMoves(cIndex) {
      const available = [];
      const board = publicBoard[cIndex];

      // If the board is won or full, return all available moves across all boards
      if (board.winner || board.cells.every(cell => cell)) {

        for (let i = 0; i < publicBoard.length; i++) {
          const b = publicBoard[i];
          if (b.winner || b.cells.every(cell => cell)) {
            continue; // skip full or won boards
          }

          for (let j = 0; j < b.cells.length; j++) {
            if (!b.cells[j]) {
              available.push(`${i + 1}${j + 1}`);
            }
          }
        }
      } else {
        // Return indices of unfilled cells
        for (let i = 0; i < board.cells.length; i++) {
          if (!board.cells[i]) {
            available.push(`${cIndex + 1}${i + 1}`);
          }
        }
      }

      return available;
    }

    async function disableAll() {
      publicBoard.forEach(board => board.cells = board.cells.map(c => c || '-'));
      await renderBoard();
    }

    function downloadReplay() {
      const blob = new Blob([
        JSON.stringify({ moves: moveHistory }, null, 2)
      ], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'royxigul-replay.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    resetBtn.onclick = async () => { await createGame(); };
    downloadBtn.onclick = downloadReplay;

    (async () => { await createGame(); })();
    // await createGame();
  </script>
</body>
</html>
